#pragma once

#include <string>
#include <type_traits>

#include <angelscript.h>

#include "AngelscriptUtils/utility/SmartPointers.h"

namespace asutils
{
/*
*	@brief Implicit cast to base class
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_UpCast(SOURCE_TYPE* self)
{
	return static_cast<DEST_TYPE*>(self);
}

/**
*	@brief Explicit cast to subclass
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_DownCast(SOURCE_TYPE* self)
{
	return dynamic_cast<DEST_TYPE*>(self);
}

/**
*	@brief Implicit cast to base class. Increments the reference count
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_UpCast_Ref(SOURCE_TYPE* self)
{
	if (self)
	{
		self->AddRef();
	}

	return static_cast<DEST_TYPE*>(self);
}

/**
*	@brief Explicit cast to subclass. Increments the reference count on successful cast
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_DownCast_Ref(SOURCE_TYPE* self)
{
	auto result = dynamic_cast<DEST_TYPE*>(self);

	if (result)
	{
		result->AddRef();
	}

	return result;
}

/**
*	@brief Registers casts between a base and derived type
*	The casting functions will trigger compile time errors if they are not compatible or don't have virtual functions (needs typeinfo, generated by virtual functions only)
*	@param engine Script engine
*	@param baseType Baseclass type
*	@param subType Subclass type
*	@param upcast Function to use for casting from derived to base
*	@param downcast Function to use for casting from base to derived
*	@tparam BASE_TYPE Base class type
*	@tparam SUB_TYPE Derived class type
*	@return Whether registration succeeded
*/
template<typename BASE_TYPE, typename SUB_TYPE>
bool RegisterCasts(asIScriptEngine& engine, const std::string& baseType, const std::string& subType,
	SUB_TYPE* (*upcast)(BASE_TYPE*), BASE_TYPE* (*downcast)(SUB_TYPE*))
{
	//Only register casts if the type being registered is not this type.
	if (baseType != subType)
	{
		std::string name = baseType + "@ opImplCast()";

		engine.RegisterObjectMethod(
			subType.c_str(), name.c_str(), asFUNCTION(upcast), asCALL_CDECL_OBJFIRST);

		name = subType + "@ opCast()";

		engine.RegisterObjectMethod(
			baseType.c_str(), name.c_str(), asFUNCTION(downcast), asCALL_CDECL_OBJFIRST);
	}

	return true;
}

/**
*	@brief @see RegisterCasts
*	Registers casts automatically based on whether the base type has AddRef and Release methods
*/
template<typename BASE_TYPE, typename SUB_TYPE, typename std::enable_if<HasAddRefAndRelease<BASE_TYPE>::value, int>::type = 0>
bool RegisterCasts_Auto(asIScriptEngine& engine, const std::string& baseType, const std::string& subType)
{
	return RegisterCasts<BASE_TYPE, SUB_TYPE>(engine, baseType, subType, Cast_UpCast_Ref, Cast_DownCast_Ref);
}

/**
*	@brief @see RegisterCasts
*	Registers casts automatically based on whether the base type has AddRef and Release methods
*/
template<typename BASE_TYPE, typename SUB_TYPE, typename std::enable_if<!HasAddRefAndRelease<BASE_TYPE>::value, int>::type = 0>
bool RegisterCasts_Auto(asIScriptEngine& engine, const std::string& baseType, const std::string& subType)
{
	return RegisterCasts<BASE_TYPE, SUB_TYPE>(engine, baseType, subType, Cast_UpCast, Cast_DownCast);
}
}
