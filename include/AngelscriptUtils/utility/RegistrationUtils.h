#pragma once

#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>

#include <angelscript.h>

#include "AngelscriptUtils/utility/SmartPointers.h"

namespace asutils
{
/*
*	@brief Implicit cast to base class
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_UpCast(SOURCE_TYPE* self)
{
	return static_cast<DEST_TYPE*>(self);
}

/**
*	@brief Explicit cast to subclass
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_DownCast(SOURCE_TYPE* self)
{
	return dynamic_cast<DEST_TYPE*>(self);
}

/**
*	@brief Implicit cast to base class. Increments the reference count
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_UpCast_Ref(SOURCE_TYPE* self)
{
	if (self)
	{
		self->AddRef();
	}

	return static_cast<DEST_TYPE*>(self);
}

/**
*	@brief Explicit cast to subclass. Increments the reference count on successful cast
*/
template<typename SOURCE_TYPE, typename DEST_TYPE>
DEST_TYPE* Cast_DownCast_Ref(SOURCE_TYPE* self)
{
	auto result = dynamic_cast<DEST_TYPE*>(self);

	if (result)
	{
		result->AddRef();
	}

	return result;
}

/**
*	@brief Registers casts between a base and derived type
*	The casting functions will trigger compile time errors if they are not compatible or don't have virtual functions
*	(needs typeinfo, generated by virtual functions only)
*	@param engine Script engine
*	@param baseType Baseclass type
*	@param subType Subclass type
*	@param upcast Function to use for casting from derived to base
*	@param downcast Function to use for casting from base to derived
*	@tparam BASE_TYPE Base class type
*	@tparam SUB_TYPE Derived class type
*	@return Whether registration succeeded
*/
template<typename BASE_TYPE, typename SUB_TYPE>
bool RegisterCasts(asIScriptEngine& engine, const std::string& baseType, const std::string& subType,
	SUB_TYPE* (*upcast)(BASE_TYPE*), BASE_TYPE* (*downcast)(SUB_TYPE*))
{
	//Only register casts if the type being registered is not this type.
	if (baseType != subType)
	{
		std::string name = baseType + "@ opImplCast()";

		engine.RegisterObjectMethod(
			subType.c_str(), name.c_str(), asFUNCTION(upcast), asCALL_CDECL_OBJFIRST);

		name = subType + "@ opCast()";

		engine.RegisterObjectMethod(
			baseType.c_str(), name.c_str(), asFUNCTION(downcast), asCALL_CDECL_OBJFIRST);
	}

	return true;
}

/**
*	@brief @see RegisterCasts
*	Registers casts automatically based on whether the base type has AddRef and Release methods
*/
template<typename BASE_TYPE, typename SUB_TYPE, typename std::enable_if<HasAddRefAndRelease<BASE_TYPE>::value, int>::type = 0>
bool RegisterCasts_Auto(asIScriptEngine& engine, const std::string& baseType, const std::string& subType)
{
	return RegisterCasts<BASE_TYPE, SUB_TYPE>(engine, baseType, subType, Cast_UpCast_Ref, Cast_DownCast_Ref);
}

/**
*	@brief @see RegisterCasts
*	Registers casts automatically based on whether the base type has AddRef and Release methods
*/
template<typename BASE_TYPE, typename SUB_TYPE, typename std::enable_if<!HasAddRefAndRelease<BASE_TYPE>::value, int>::type = 0>
bool RegisterCasts_Auto(asIScriptEngine& engine, const std::string& baseType, const std::string& subType)
{
	return RegisterCasts<BASE_TYPE, SUB_TYPE>(engine, baseType, subType, Cast_UpCast, Cast_DownCast);
}

/**
*	@brief Registers a variadic function
*	@param regFunctor Functor that handles function/method registration
*	@param arguments Mandatory parameters
*	@param minimumVariadicParameterCount Minimum number of variadic parameters
*	@param maximumVariadicParameterCount Maximum number of variadic parameters
*	@param funcPtr Function pointer. Use asFUNCTION or asMETHOD
*	@param auxiliary Optional. Auxiliary pointer
*/
template<typename REGFUNCTOR>
void RegisterVariadicFunction(asIScriptEngine& engine, REGFUNCTOR regFunctor,
	const std::string& returnType, const std::string& functionName, const std::string& arguments,
	const size_t minimumVariadicParameterCount, const size_t maximumVariadicParameterCount,
	const asSFuncPtr& funcPtr, void* auxiliary)
{
	if (maximumVariadicParameterCount < minimumVariadicParameterCount)
	{
		throw std::out_of_range("Maximum variadic parameter count must be larger than or equal to minimum variadic parameter count");
	}

	std::stringstream stream;

	//Variadic parameters has a predictable format, so just format the beginning once and reset the write position to just before the ')' every loop.
	stream << returnType << ' ' << functionName << '(' << arguments;

	//Figure out if there are any arguments before the variadic parameters.
	const bool hasOtherParameters = std::string(arguments).find_first_not_of(" \t") != std::string::npos;

	auto resetPosition = stream.tellp();

	stream << ')';

	const size_t uiNumVariations = (maximumVariadicParameterCount - minimumVariadicParameterCount) + 1;

	size_t variadicParameterCount = minimumVariadicParameterCount;

	for (size_t variant = 0; variant < uiNumVariations; ++variant)
	{
		stream.seekp(resetPosition);

		if (variadicParameterCount > 0)
		{
			if (hasOtherParameters || variadicParameterCount > 1)
			{
				stream << ", ";
			}

			stream << "?& in";
		}

		resetPosition = stream.tellp();

		stream << ')';

		auto str = stream.str();

		regFunctor(engine, str, funcPtr, asCALL_GENERIC, auxiliary);

		++variadicParameterCount;
	}
}

/**
*	@brief Functor that can register global functions
*/
struct RegisterGlobalFunction final
{
	int operator()(asIScriptEngine& engine, const std::string declaration,
		const asSFuncPtr& funcPtr, asDWORD callConv, void* pAuxiliary = nullptr)
	{
		return engine.RegisterGlobalFunction(declaration.c_str(), funcPtr, callConv, pAuxiliary);
	}
};

/**
*	@brief Registers a variadic function
*	@param arguments Mandatory parameters
*	@param minimumVariadicParameterCount Minimum number of variadic parameters
*	@param maximumVariadicParameterCount Maximum number of variadic parameters
*	@param funcPtr Function pointer. Use asFUNCTION
*	@param auxiliary Optional. Auxiliary pointer
*/
inline void RegisterVariadicFunction(asIScriptEngine& engine,
	const std::string& returnType, const std::string& functionName, const std::string& arguments,
	const size_t minimumVariadicParameterCount, const size_t maximumVariadicParameterCount,
	const asSFuncPtr& funcPtr, void* auxiliary = nullptr)
{
	RegisterVariadicFunction(engine, RegisterGlobalFunction(),
		returnType, functionName, arguments,
		minimumVariadicParameterCount, maximumVariadicParameterCount,
		funcPtr, auxiliary);
}

/**
*	@brief Functor that can register object methods
*/
struct RegisterMethod final
{
	const std::string objectName;

	RegisterMethod(std::string&& objectName)
		: objectName(std::move(objectName))
	{
	}

	RegisterMethod(const RegisterMethod& other) = default;

	int operator()(asIScriptEngine& engine, const std::string declaration,
		const asSFuncPtr& funcPtr, asDWORD callConv, void* auxiliary = nullptr)
	{
		return engine.RegisterObjectMethod(objectName.c_str(), declaration.c_str(), funcPtr, callConv, auxiliary);
	}

private:
	RegisterMethod& operator=(const RegisterMethod&) = delete;
};

/**
*	@brief Registers a variadic method
*	@param pszArguments Mandatory parameters
*	@param minimumVariadicParameterCount Minimum number of variadic parameters
*	@param maximumVariadicParameterCount Maximum number of variadic parameters
*	@param funcPtr Function pointer. Use asMETHOD
*	@param auxiliary Optional. Auxiliary pointer
*/
inline void RegisterVariadicMethod(asIScriptEngine& engine,
	std::string&& objectName,
	const std::string& returnType, const std::string& functionName, const std::string& arguments,
	size_t uiMinArgs, size_t uiMaxArgs,
	const asSFuncPtr& funcPtr, void* auxiliary = nullptr)
{
	RegisterVariadicFunction(engine, RegisterMethod(std::move(objectName)),
		returnType, functionName, arguments,
		uiMinArgs, uiMaxArgs,
		funcPtr, auxiliary);
}
}
